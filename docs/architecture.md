# Toolbox architecture recap

This repository does not ship the Toolbox runtime. It documents how community
bundles integrate with the upstream services so maintainers can package assets
correctly.

## Runtime components

1. **FastAPI control plane (`toolbox.api`)** – Hosts the REST API that manages
   toolkit installation, telemetry, and operator workflows.
2. **Celery worker (`toolbox.worker`)** – Executes long-running tasks declared in
   each toolkit's `worker/` package and streams progress updates back to the
   control plane.
3. **React App Shell (`toolbox.ui`)** – Renders operator dashboards and routes.
   Toolkit frontends mount here by exposing entry points under
   `frontend/manifest.ts`.
4. **Dynamic bundler (`toolkit_bundle_service.py`)** – Lives in this repository
   and packages `toolkits/<slug>/` into a bundle when Toolbox or an operator
   requests `/toolkits/<slug>/bundle.zip`.

## How toolkits integrate

- `toolkit.json` declares backend routers, Celery task modules, and frontend
  assets. Toolbox reads this manifest to install bundles.
- Backend modules must register routers in `backend/app.py` and expose the
  `create_router()` factory referenced in the manifest.
- Worker modules register Celery tasks in `worker/__init__.py`.
- Frontend modules expose React routes and resource manifests consumed by the
  App Shell.
- Documentation under `toolkits/<slug>/docs/` drives the public catalog entries
  generated by `scripts/sync_toolkit_assets.py`.

## Additional references

- [Dynamic bundler operations](bundler.md)
- [Toolkit authoring checklist](toolkit-authoring.md)
- [Catalog maintenance](catalog.md)
